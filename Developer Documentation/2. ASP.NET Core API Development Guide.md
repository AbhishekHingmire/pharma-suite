# ASP.NET Core Web API Development Guide for Pharma Suite

## ðŸ“‹ Table of Contents
1. [Project Setup and Architecture](#1-project-setup-and-architecture)
2. [Technology Stack and Dependencies](#2-technology-stack-and-dependencies)
3. [Database Design](#3-database-design)
4. [Authentication and Authorization](#4-authentication-and-authorization)
5. [API Structure and Best Practices](#5-api-structure-and-best-practices)
6. [Controllers and Endpoints](#6-controllers-and-endpoints)
7. [Validation and Error Handling](#7-validation-and-error-handling)
8. [Performance Optimization](#8-performance-optimization)
9. [Deployment Considerations](#9-deployment-considerations)

---

## 1. Project Setup and Architecture

### 1.1 Solution Structure

Create a clean architecture solution with these projects:

```
PharmaSuite/
â”œâ”€â”€ PharmaSuite.API/                    # Web API Project
â”‚   â”œâ”€â”€ Controllers/
â”‚   â”œâ”€â”€ Middleware/
â”‚   â”œâ”€â”€ Program.cs
â”‚   â””â”€â”€ appsettings.json
â”‚
â”œâ”€â”€ PharmaSuite.Core/                   # Domain Layer
â”‚   â”œâ”€â”€ Entities/                       # Database models
â”‚   â”œâ”€â”€ Interfaces/                     # Repository interfaces
â”‚   â”œâ”€â”€ DTOs/                          # Data Transfer Objects
â”‚   â””â”€â”€ Constants/
â”‚
â”œâ”€â”€ PharmaSuite.Infrastructure/         # Data Access Layer
â”‚   â”œâ”€â”€ Data/                          # DbContext
â”‚   â”œâ”€â”€ Repositories/                  # Repository implementations
â”‚   â””â”€â”€ Migrations/
â”‚
â””â”€â”€ PharmaSuite.Services/              # Business Logic Layer
    â”œâ”€â”€ Services/                      # Business logic
    â”œâ”€â”€ Validators/                    # FluentValidation rules
    â””â”€â”€ Helpers/
```

### 1.2 Creating the Project

**Commands:**
```bash
# Create solution
dotnet new sln -n PharmaSuite

# Create projects
dotnet new webapi -n PharmaSuite.API
dotnet new classlib -n PharmaSuite.Core
dotnet new classlib -n PharmaSuite.Infrastructure
dotnet new classlib -n PharmaSuite.Services

# Add projects to solution
dotnet sln add PharmaSuite.API/PharmaSuite.API.csproj
dotnet sln add PharmaSuite.Core/PharmaSuite.Core.csproj
dotnet sln add PharmaSuite.Infrastructure/PharmaSuite.Infrastructure.csproj
dotnet sln add PharmaSuite.Services/PharmaSuite.Services.csproj

# Add project references
cd PharmaSuite.API
dotnet add reference ../PharmaSuite.Core/PharmaSuite.Core.csproj
dotnet add reference ../PharmaSuite.Services/PharmaSuite.Services.csproj

cd ../PharmaSuite.Services
dotnet add reference ../PharmaSuite.Core/PharmaSuite.Core.csproj
dotnet add reference ../PharmaSuite.Infrastructure/PharmaSuite.Infrastructure.csproj

cd ../PharmaSuite.Infrastructure
dotnet add reference ../PharmaSuite.Core/PharmaSuite.Core.csproj
```

---

## 2. Technology Stack and Dependencies

### 2.1 Required NuGet Packages

**PharmaSuite.API:**
```bash
dotnet add package Microsoft.AspNetCore.Authentication.JwtBearer
dotnet add package Microsoft.AspNetCore.Identity.EntityFrameworkCore
dotnet add package Swashbuckle.AspNetCore
dotnet add package Serilog.AspNetCore
dotnet add package AutoMapper.Extensions.Microsoft.DependencyInjection
```

**PharmaSuite.Infrastructure:**
```bash
dotnet add package Microsoft.EntityFrameworkCore.SqlServer
dotnet add package Microsoft.EntityFrameworkCore.Tools
dotnet add package Microsoft.EntityFrameworkCore.Design
```

**PharmaSuite.Services:**
```bash
dotnet add package FluentValidation.AspNetCore
dotnet add package AutoMapper
```

### 2.2 Why These Technologies?

| Technology | Purpose | Benefit |
|------------|---------|---------|
| **Entity Framework Core** | ORM for database operations | Type-safe queries, migrations, optimistic concurrency |
| **JWT** | Stateless authentication | Scalable, no server-side sessions (cost reduction) |
| **AutoMapper** | Object mapping | Reduces boilerplate code |
| **FluentValidation** | Input validation | Clean, testable validation rules |
| **Serilog** | Logging | Structured logging for debugging |
| **Swagger** | API documentation | Auto-generated API docs |

---

## 3. Database Design

### 3.1 Entity Models (PharmaSuite.Core/Entities/)

#### User.cs
```csharp
public class User
{
    public int Id { get; set; }
    
    [Required, MaxLength(100)]
    public string Name { get; set; }
    
    [Required, MaxLength(15)]
    public string Mobile { get; set; }
    
    [Required]
    public UserRole Role { get; set; } // Enum: Admin, Staff
    
    [Required, MaxLength(255)]
    public string PasswordHash { get; set; }
    
    public bool IsActive { get; set; } = true;
    
    public DateTime? LastLoginAt { get; set; }
    
    public DateTime CreatedAt { get; set; }
    
    // Optimistic concurrency
    [Timestamp]
    public byte[] RowVersion { get; set; }
    
    // Navigation properties
    public ICollection<Sale> Sales { get; set; }
    public ICollection<Purchase> Purchases { get; set; }
}

public enum UserRole
{
    Admin = 1,
    Staff = 2
}
```

#### Company.cs
```csharp
public class Company
{
    public int Id { get; set; }
    
    [Required, MaxLength(200)]
    public string Name { get; set; }
    
    [MaxLength(500)]
    public string LogoUrl { get; set; }
    
    [Required, MaxLength(50)]
    public string Contact { get; set; }
    
    [MaxLength(100), EmailAddress]
    public string Email { get; set; }
    
    [MaxLength(500)]
    public string Address { get; set; }
    
    [MaxLength(15)]
    public string GSTIN { get; set; }
    
    [Required, MaxLength(100)]
    public string PaymentTerms { get; set; } // e.g., "Net 30 days"
    
    public bool IsActive { get; set; } = true;
    
    [Timestamp]
    public byte[] RowVersion { get; set; }
    
    // Navigation
    public ICollection<Purchase> Purchases { get; set; }
    public ICollection<Scheme> Schemes { get; set; }
}
```

#### Product.cs
```csharp
public class Product
{
    public int Id { get; set; }
    
    [Required, MaxLength(200)]
    public string Name { get; set; } // Generic name
    
    [Required, MaxLength(200)]
    public string GenericName { get; set; }
    
    [Required, MaxLength(20)]
    public string HSNCode { get; set; }
    
    [Required]
    public decimal GSTPercent { get; set; } // 0, 5, 12, 18, 28
    
    [MaxLength(100)]
    public string Packing { get; set; }
    
    public int MinStockLevel { get; set; }
    
    public bool IsActive { get; set; } = true;
    
    [Timestamp]
    public byte[] RowVersion { get; set; }
    
    // Navigation
    public ICollection<InventoryBatch> InventoryBatches { get; set; }
    public ICollection<RateMaster> RateMasters { get; set; }
}
```

#### Customer.cs
```csharp
public class Customer
{
    public int Id { get; set; }
    
    [Required, MaxLength(200)]
    public string Name { get; set; }
    
    [Required]
    public CustomerType Type { get; set; } // A, B, C
    
    [Required, MaxLength(15)]
    public string Phone { get; set; }
    
    [MaxLength(100), EmailAddress]
    public string Email { get; set; }
    
    [MaxLength(500)]
    public string Address { get; set; }
    
    [MaxLength(15)]
    public string GSTIN { get; set; }
    
    [Required]
    public decimal CreditLimit { get; set; }
    
    public int CreditDays { get; set; }
    
    public decimal Outstanding { get; set; } = 0;
    
    public bool IsActive { get; set; } = true;
    
    [Timestamp]
    public byte[] RowVersion { get; set; }
    
    // Navigation
    public ICollection<Sale> Sales { get; set; }
    public ICollection<Payment> Payments { get; set; }
}

public enum CustomerType
{
    A = 1,
    B = 2,
    C = 3
}
```

#### Purchase.cs
```csharp
public class Purchase
{
    public int Id { get; set; }
    
    public int CompanyId { get; set; }
    
    [Required, MaxLength(50)]
    public string InvoiceNo { get; set; }
    
    [Required]
    public DateTime PurchaseDate { get; set; }
    
    [Required]
    public decimal Subtotal { get; set; }
    
    [Required]
    public decimal GSTAmount { get; set; }
    
    [Required]
    public decimal Total { get; set; }
    
    [Required]
    public PaymentStatus PaymentStatus { get; set; }
    
    public decimal PaidAmount { get; set; }
    
    [MaxLength(100)]
    public string TransactionId { get; set; }
    
    public int CreatedByUserId { get; set; }
    
    public DateTime CreatedAt { get; set; }
    
    public DateTime? LastEditedAt { get; set; }
    
    [Timestamp]
    public byte[] RowVersion { get; set; }
    
    // Navigation
    public Company Company { get; set; }
    public User CreatedByUser { get; set; }
    public ICollection<PurchaseItem> PurchaseItems { get; set; }
}

public enum PaymentStatus
{
    Pending = 1,
    Partial = 2,
    Paid = 3
}
```

#### PurchaseItem.cs
```csharp
public class PurchaseItem
{
    public int Id { get; set; }
    
    public int PurchaseId { get; set; }
    
    public int ProductId { get; set; }
    
    public int CompanyId { get; set; }
    
    [Required, MaxLength(200)]
    public string BrandName { get; set; }
    
    [Required]
    public int Quantity { get; set; }
    
    public int FreeQuantity { get; set; }
    
    [Required, MaxLength(50)]
    public string BatchNumber { get; set; }
    
    [Required]
    public DateTime ExpiryDate { get; set; }
    
    [Required]
    public decimal Rate { get; set; }
    
    [Required]
    public decimal Amount { get; set; }
    
    public int? SchemeId { get; set; }
    
    // Navigation
    public Purchase Purchase { get; set; }
    public Product Product { get; set; }
    public Company Company { get; set; }
    public Scheme Scheme { get; set; }
}
```

#### Sale.cs
```csharp
public class Sale
{
    public int Id { get; set; }
    
    public int CustomerId { get; set; }
    
    [Required, MaxLength(50)]
    public string InvoiceNo { get; set; }
    
    [Required]
    public DateTime SaleDate { get; set; }
    
    [Required]
    public decimal Subtotal { get; set; }
    
    [Required]
    public decimal GSTAmount { get; set; }
    
    [Required]
    public decimal Total { get; set; }
    
    [Required]
    public PaymentStatus PaymentStatus { get; set; }
    
    public decimal PaidAmount { get; set; }
    
    public int CreatedByUserId { get; set; }
    
    public DateTime CreatedAt { get; set; }
    
    [Timestamp]
    public byte[] RowVersion { get; set; }
    
    // Navigation
    public Customer Customer { get; set; }
    public User CreatedByUser { get; set; }
    public ICollection<SaleItem> SaleItems { get; set; }
}
```

#### SaleItem.cs
```csharp
public class SaleItem
{
    public int Id { get; set; }
    
    public int SaleId { get; set; }
    
    public int ProductId { get; set; }
    
    public int InventoryBatchId { get; set; }
    
    [Required, MaxLength(200)]
    public string BrandName { get; set; }
    
    [Required]
    public int Quantity { get; set; }
    
    [Required]
    public decimal Rate { get; set; }
    
    [Required]
    public decimal Amount { get; set; }
    
    // Navigation
    public Sale Sale { get; set; }
    public Product Product { get; set; }
    public InventoryBatch InventoryBatch { get; set; }
}
```

#### InventoryBatch.cs
```csharp
public class InventoryBatch
{
    public int Id { get; set; }
    
    public int ProductId { get; set; }
    
    public int CompanyId { get; set; }
    
    [Required, MaxLength(200)]
    public string BrandName { get; set; }
    
    [Required, MaxLength(50)]
    public string BatchNumber { get; set; }
    
    [Required]
    public int AvailableQuantity { get; set; }
    
    [Required]
    public DateTime PurchaseDate { get; set; }
    
    [Required]
    public DateTime ExpiryDate { get; set; }
    
    [Required]
    public decimal CostPrice { get; set; }
    
    [Timestamp]
    public byte[] RowVersion { get; set; }
    
    // Navigation
    public Product Product { get; set; }
    public Company Company { get; set; }
}
```

#### Scheme.cs
```csharp
public class Scheme
{
    public int Id { get; set; }
    
    public int CompanyId { get; set; }
    
    [Required]
    public SchemeType Type { get; set; }
    
    public int? BuyQuantity { get; set; }
    
    public int? FreeQuantity { get; set; }
    
    public decimal? DiscountPercent { get; set; }
    
    [Required]
    public DateTime ValidFrom { get; set; }
    
    [Required]
    public DateTime ValidTo { get; set; }
    
    public bool IsApplicableToAllProducts { get; set; }
    
    public bool IsActive { get; set; } = true;
    
    [Timestamp]
    public byte[] RowVersion { get; set; }
    
    // Navigation
    public Company Company { get; set; }
    public ICollection<SchemeProduct> SchemeProducts { get; set; }
}

public enum SchemeType
{
    FreeQuantity = 1,
    Discount = 2,
    Slab = 3
}
```

#### SchemeProduct.cs (Many-to-Many)
```csharp
public class SchemeProduct
{
    public int SchemeId { get; set; }
    public int ProductId { get; set; }
    
    public Scheme Scheme { get; set; }
    public Product Product { get; set; }
}
```

#### RateMaster.cs
```csharp
public class RateMaster
{
    public int Id { get; set; }
    
    [Required]
    public CustomerType CustomerType { get; set; }
    
    public int ProductId { get; set; }
    
    [Required]
    public decimal MarginPercent { get; set; }
    
    public decimal? MinimumPrice { get; set; }
    
    [Timestamp]
    public byte[] RowVersion { get; set; }
    
    // Navigation
    public Product Product { get; set; }
}
```

#### Payment.cs
```csharp
public class Payment
{
    public int Id { get; set; }
    
    public int CustomerId { get; set; }
    
    public int? SaleId { get; set; }
    
    [Required]
    public decimal Amount { get; set; }
    
    [Required]
    public DateTime PaymentDate { get; set; }
    
    [Required]
    public PaymentMode Mode { get; set; }
    
    [MaxLength(100)]
    public string ReferenceNumber { get; set; }
    
    [MaxLength(500)]
    public string Notes { get; set; }
    
    public int ReceivedByUserId { get; set; }
    
    public DateTime CreatedAt { get; set; }
    
    // Navigation
    public Customer Customer { get; set; }
    public Sale Sale { get; set; }
    public User ReceivedByUser { get; set; }
}

public enum PaymentMode
{
    Cash = 1,
    Card = 2,
    UPI = 3,
    NetBanking = 4,
    Cheque = 5
}
```

### 3.2 DbContext Configuration

**PharmaSuite.Infrastructure/Data/ApplicationDbContext.cs:**
```csharp
public class ApplicationDbContext : DbContext
{
    public ApplicationDbContext(DbContextOptions<ApplicationDbContext> options)
        : base(options)
    {
    }

    public DbSet<User> Users { get; set; }
    public DbSet<Company> Companies { get; set; }
    public DbSet<Product> Products { get; set; }
    public DbSet<Customer> Customers { get; set; }
    public DbSet<Purchase> Purchases { get; set; }
    public DbSet<PurchaseItem> PurchaseItems { get; set; }
    public DbSet<Sale> Sales { get; set; }
    public DbSet<SaleItem> SaleItems { get; set; }
    public DbSet<InventoryBatch> InventoryBatches { get; set; }
    public DbSet<Scheme> Schemes { get; set; }
    public DbSet<SchemeProduct> SchemeProducts { get; set; }
    public DbSet<RateMaster> RateMasters { get; set; }
    public DbSet<Payment> Payments { get; set; }

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        base.OnModelCreating(modelBuilder);

        // Configure decimal precision
        modelBuilder.Entity<Purchase>()
            .Property(p => p.Subtotal)
            .HasColumnType("decimal(18,2)");
        
        modelBuilder.Entity<Purchase>()
            .Property(p => p.GSTAmount)
            .HasColumnType("decimal(18,2)");
        
        modelBuilder.Entity<Purchase>()
            .Property(p => p.Total)
            .HasColumnType("decimal(18,2)");
        
        // Apply same for Sale, PurchaseItem, SaleItem, etc.

        // Configure relationships
        modelBuilder.Entity<Purchase>()
            .HasOne(p => p.Company)
            .WithMany(c => c.Purchases)
            .HasForeignKey(p => p.CompanyId)
            .OnDelete(DeleteBehavior.Restrict);

        // Many-to-Many for Scheme-Products
        modelBuilder.Entity<SchemeProduct>()
            .HasKey(sp => new { sp.SchemeId, sp.ProductId });

        modelBuilder.Entity<SchemeProduct>()
            .HasOne(sp => sp.Scheme)
            .WithMany(s => s.SchemeProducts)
            .HasForeignKey(sp => sp.SchemeId);

        modelBuilder.Entity<SchemeProduct>()
            .HasOne(sp => sp.Product)
            .WithMany()
            .HasForeignKey(sp => sp.ProductId);

        // Indexes for performance
        modelBuilder.Entity<Purchase>()
            .HasIndex(p => p.InvoiceNo)
            .IsUnique();

        modelBuilder.Entity<Sale>()
            .HasIndex(s => s.InvoiceNo)
            .IsUnique();

        modelBuilder.Entity<InventoryBatch>()
            .HasIndex(i => new { i.ProductId, i.BatchNumber });

        modelBuilder.Entity<Customer>()
            .HasIndex(c => c.Phone);
    }
}
```

### 3.3 Connection String

**appsettings.json:**
```json
{
  "ConnectionStrings": {
    "DefaultConnection": "Server=.;Database=PharmaSuiteDB;Trusted_Connection=True;TrustServerCertificate=True;MultipleActiveResultSets=true"
  },
  "Jwt": {
    "Key": "YourSuperSecretKeyHere-MinimumLength32Characters!",
    "Issuer": "PharmaSuiteAPI",
    "Audience": "PharmaSuiteClient",
    "ExpiryInHours": 24
  }
}
```

### 3.4 Create Migrations

```bash
cd PharmaSuite.Infrastructure
dotnet ef migrations add InitialCreate --startup-project ../PharmaSuite.API
dotnet ef database update --startup-project ../PharmaSuite.API
```

---

## 4. Authentication and Authorization

### 4.1 JWT Configuration

**PharmaSuite.API/Program.cs:**
```csharp
// Add services
builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options =>
    {
        options.TokenValidationParameters = new TokenValidationParameters
        {
            ValidateIssuer = true,
            ValidateAudience = true,
            ValidateLifetime = true,
            ValidateIssuerSigningKey = true,
            ValidIssuer = builder.Configuration["Jwt:Issuer"],
            ValidAudience = builder.Configuration["Jwt:Audience"],
            IssuerSigningKey = new SymmetricSecurityKey(
                Encoding.UTF8.GetBytes(builder.Configuration["Jwt:Key"]))
        };
    });

builder.Services.AddAuthorization(options =>
{
    options.AddPolicy("AdminOnly", policy => 
        policy.RequireRole("Admin"));
    
    options.AddPolicy("StaffOrAdmin", policy => 
        policy.RequireRole("Admin", "Staff"));
});

// In middleware
app.UseAuthentication();
app.UseAuthorization();
```

### 4.2 Token Generation Service

**PharmaSuite.Services/Services/TokenService.cs:**
```csharp
public interface ITokenService
{
    string GenerateToken(User user);
}

public class TokenService : ITokenService
{
    private readonly IConfiguration _configuration;

    public TokenService(IConfiguration configuration)
    {
        _configuration = configuration;
    }

    public string GenerateToken(User user)
    {
        var securityKey = new SymmetricSecurityKey(
            Encoding.UTF8.GetBytes(_configuration["Jwt:Key"]));
        
        var credentials = new SigningCredentials(
            securityKey, SecurityAlgorithms.HmacSha256);

        var claims = new[]
        {
            new Claim(ClaimTypes.NameIdentifier, user.Id.ToString()),
            new Claim(ClaimTypes.Name, user.Name),
            new Claim(ClaimTypes.MobilePhone, user.Mobile),
            new Claim(ClaimTypes.Role, user.Role.ToString())
        };

        var token = new JwtSecurityToken(
            issuer: _configuration["Jwt:Issuer"],
            audience: _configuration["Jwt:Audience"],
            claims: claims,
            expires: DateTime.Now.AddHours(
                Convert.ToDouble(_configuration["Jwt:ExpiryInHours"])),
            signingCredentials: credentials);

        return new JwtSecurityTokenHandler().WriteToken(token);
    }
}
```

### 4.3 Password Hashing

**PharmaSuite.Services/Helpers/PasswordHelper.cs:**
```csharp
public static class PasswordHelper
{
    public static string HashPassword(string password)
    {
        return BCrypt.Net.BCrypt.HashPassword(password);
    }

    public static bool VerifyPassword(string password, string hash)
    {
        return BCrypt.Net.BCrypt.Verify(password, hash);
    }
}
```

---

## 5. API Structure and Best Practices

### 5.1 Repository Pattern

**Interface (PharmaSuite.Core/Interfaces/IRepository.cs):**
```csharp
public interface IRepository<T> where T : class
{
    Task<T> GetByIdAsync(int id);
    Task<IEnumerable<T>> GetAllAsync();
    Task<T> AddAsync(T entity);
    Task UpdateAsync(T entity);
    Task DeleteAsync(int id);
    Task<bool> ExistsAsync(int id);
}
```

**Implementation Example:**
```csharp
public class Repository<T> : IRepository<T> where T : class
{
    private readonly ApplicationDbContext _context;
    private readonly DbSet<T> _dbSet;

    public Repository(ApplicationDbContext context)
    {
        _context = context;
        _dbSet = context.Set<T>();
    }

    public async Task<T> GetByIdAsync(int id)
    {
        return await _dbSet.FindAsync(id);
    }

    public async Task<IEnumerable<T>> GetAllAsync()
    {
        return await _dbSet.AsNoTracking().ToListAsync();
    }

    public async Task<T> AddAsync(T entity)
    {
        await _dbSet.AddAsync(entity);
        await _context.SaveChangesAsync();
        return entity;
    }

    public async Task UpdateAsync(T entity)
    {
        _dbSet.Update(entity);
        await _context.SaveChangesAsync();
    }

    public async Task DeleteAsync(int id)
    {
        var entity = await GetByIdAsync(id);
        if (entity != null)
        {
            _dbSet.Remove(entity);
            await _context.SaveChangesAsync();
        }
    }

    public async Task<bool> ExistsAsync(int id)
    {
        return await _dbSet.FindAsync(id) != null;
    }
}
```

### 5.2 DTOs (Data Transfer Objects)

**PharmaSuite.Core/DTOs/PurchaseDto.cs:**
```csharp
public class PurchaseDto
{
    public int Id { get; set; }
    public int CompanyId { get; set; }
    public string CompanyName { get; set; }
    public string InvoiceNo { get; set; }
    public DateTime PurchaseDate { get; set; }
    public decimal Subtotal { get; set; }
    public decimal GSTAmount { get; set; }
    public decimal Total { get; set; }
    public string PaymentStatus { get; set; }
    public decimal PaidAmount { get; set; }
    public decimal PendingAmount { get; set; }
    public List<PurchaseItemDto> Items { get; set; }
}

public class CreatePurchaseDto
{
    [Required]
    public int CompanyId { get; set; }
    
    [Required]
    public DateTime PurchaseDate { get; set; }
    
    [Required]
    public string PaymentStatus { get; set; }
    
    public decimal PaidAmount { get; set; }
    
    public string TransactionId { get; set; }
    
    [Required, MinLength(1)]
    public List<CreatePurchaseItemDto> Items { get; set; }
}
```

### 5.3 AutoMapper Profile

**PharmaSuite.Services/Mappings/MappingProfile.cs:**
```csharp
public class MappingProfile : Profile
{
    public MappingProfile()
    {
        CreateMap<Purchase, PurchaseDto>()
            .ForMember(dest => dest.CompanyName, 
                opt => opt.MapFrom(src => src.Company.Name))
            .ForMember(dest => dest.PendingAmount,
                opt => opt.MapFrom(src => src.Total - src.PaidAmount));

        CreateMap<CreatePurchaseDto, Purchase>();
        
        // Add other mappings
    }
}
```

---

## 6. Controllers and Endpoints

### 6.1 AuthController

**Endpoints:**
- `POST /api/auth/login` - User login
- `POST /api/auth/register` - Register new user (admin only)
- `POST /api/auth/change-password` - Change password

**Models:**
```csharp
public class LoginDto
{
    [Required]
    public string Mobile { get; set; }
    
    [Required]
    public string Password { get; set; }
}

public class LoginResponseDto
{
    public int UserId { get; set; }
    public string Name { get; set; }
    public string Mobile { get; set; }
    public string Role { get; set; }
    public string Token { get; set; }
}
```

**Controller Method Example:**
```csharp
[ApiController]
[Route("api/[controller]")]
public class AuthController : ControllerBase
{
    private readonly IAuthService _authService;

    public AuthController(IAuthService authService)
    {
        _authService = authService;
    }

    [HttpPost("login")]
    public async Task<IActionResult> Login([FromBody] LoginDto loginDto)
    {
        var result = await _authService.LoginAsync(loginDto);
        
        if (result == null)
            return Unauthorized(new { message = "Invalid credentials" });
        
        return Ok(result);
    }
}
```

### 6.2 PurchaseController

**Endpoints:**
- `GET /api/purchases` - Get all purchases (with filters: status, company, date range)
- `GET /api/purchases/{id}` - Get purchase by ID
- `POST /api/purchases` - Create new purchase (admin only)
- `PUT /api/purchases/{id}` - Update purchase (admin only)
- `DELETE /api/purchases/{id}` - Delete purchase (admin only)
- `GET /api/purchases/pending` - Get purchases with pending payments
- `PATCH /api/purchases/{id}/payment` - Update payment status

**Controller:**
```csharp
[ApiController]
[Route("api/[controller]")]
[Authorize]
public class PurchasesController : ControllerBase
{
    private readonly IPurchaseService _purchaseService;

    public PurchasesController(IPurchaseService purchaseService)
    {
        _purchaseService = purchaseService;
    }

    [HttpGet]
    public async Task<IActionResult> GetAll(
        [FromQuery] string status = null,
        [FromQuery] int? companyId = null,
        [FromQuery] DateTime? fromDate = null,
        [FromQuery] DateTime? toDate = null,
        [FromQuery] int page = 1,
        [FromQuery] int pageSize = 20)
    {
        var purchases = await _purchaseService.GetAllAsync(
            status, companyId, fromDate, toDate, page, pageSize);
        
        return Ok(purchases);
    }

    [HttpGet("{id}")]
    public async Task<IActionResult> GetById(int id)
    {
        var purchase = await _purchaseService.GetByIdAsync(id);
        
        if (purchase == null)
            return NotFound();
        
        return Ok(purchase);
    }

    [HttpPost]
    [Authorize(Policy = "AdminOnly")]
    public async Task<IActionResult> Create([FromBody] CreatePurchaseDto dto)
    {
        var userId = int.Parse(User.FindFirst(ClaimTypes.NameIdentifier).Value);
        var purchase = await _purchaseService.CreateAsync(dto, userId);
        
        return CreatedAtAction(nameof(GetById), 
            new { id = purchase.Id }, purchase);
    }

    [HttpPut("{id}")]
    [Authorize(Policy = "AdminOnly")]
    public async Task<IActionResult> Update(int id, [FromBody] UpdatePurchaseDto dto)
    {
        try
        {
            await _purchaseService.UpdateAsync(id, dto);
            return NoContent();
        }
        catch (DbUpdateConcurrencyException)
        {
            return Conflict(new { message = "Purchase was modified by another user" });
        }
    }

    [HttpDelete("{id}")]
    [Authorize(Policy = "AdminOnly")]
    public async Task<IActionResult> Delete(int id)
    {
        await _purchaseService.DeleteAsync(id);
        return NoContent();
    }
}
```

### 6.3 SalesController

**Endpoints:**
- `GET /api/sales` - Get all sales
- `GET /api/sales/{id}` - Get sale by ID
- `POST /api/sales` - Create new sale
- `PUT /api/sales/{id}` - Update sale
- `DELETE /api/sales/{id}` - Delete sale (admin only)
- `GET /api/sales/customer/{customerId}` - Get sales by customer
- `PATCH /api/sales/{id}/payment` - Update payment status

**Models:**
```csharp
public class CreateSaleDto
{
    [Required]
    public int CustomerId { get; set; }
    
    [Required]
    public DateTime SaleDate { get; set; }
    
    [Required]
    public string PaymentStatus { get; set; }
    
    public decimal PaidAmount { get; set; }
    
    [Required, MinLength(1)]
    public List<CreateSaleItemDto> Items { get; set; }
}

public class CreateSaleItemDto
{
    [Required]
    public int ProductId { get; set; }
    
    [Required]
    public int InventoryBatchId { get; set; }
    
    [Required]
    public string BrandName { get; set; }
    
    [Required, Range(1, int.MaxValue)]
    public int Quantity { get; set; }
}
```

### 6.4 InventoryController

**Endpoints:**
- `GET /api/inventory` - Get all inventory
- `GET /api/inventory/product/{productId}` - Get inventory by product
- `GET /api/inventory/low-stock` - Get low stock items
- `GET /api/inventory/expiring` - Get expiring items (within days parameter)
- `GET /api/inventory/batch/{batchId}` - Get specific batch details
- `POST /api/inventory/adjust` - Manual stock adjustment (admin only)

**Models:**
```csharp
public class InventoryBatchDto
{
    public int Id { get; set; }
    public int ProductId { get; set; }
    public string ProductName { get; set; }
    public string BrandName { get; set; }
    public string BatchNumber { get; set; }
    public int AvailableQuantity { get; set; }
    public DateTime ExpiryDate { get; set; }
    public int DaysUntilExpiry { get; set; }
    public decimal CostPrice { get; set; }
    public decimal TotalValue { get; set; }
}

public class StockAdjustmentDto
{
    [Required]
    public int InventoryBatchId { get; set; }
    
    [Required]
    public int AdjustmentQuantity { get; set; } // Positive or negative
    
    [Required]
    public string Reason { get; set; }
}
```

### 6.5 PaymentsController

**Endpoints:**
- `GET /api/payments` - Get all payments
- `GET /api/payments/customer/{customerId}` - Get payments by customer
- `POST /api/payments/receive` - Receive payment from customer
- `POST /api/payments/make` - Make payment to company (for purchase)
- `GET /api/payments/pending` - Get pending payments

**Models:**
```csharp
public class ReceivePaymentDto
{
    [Required]
    public int CustomerId { get; set; }
    
    [Required, Range(0.01, double.MaxValue)]
    public decimal Amount { get; set; }
    
    [Required]
    public DateTime PaymentDate { get; set; }
    
    [Required]
    public string PaymentMode { get; set; }
    
    public string ReferenceNumber { get; set; }
    
    public string Notes { get; set; }
    
    public List<int> InvoiceIds { get; set; } // Optional invoice allocation
}
```

### 6.6 CompaniesController

**Endpoints:**
- `GET /api/companies` - Get all companies
- `GET /api/companies/{id}` - Get company by ID
- `POST /api/companies` - Create company (admin only)
- `PUT /api/companies/{id}` - Update company (admin only)
- `DELETE /api/companies/{id}` - Delete company (admin only)
- `GET /api/companies/{id}/schemes` - Get schemes for company

### 6.7 ProductsController

**Endpoints:**
- `GET /api/products` - Get all products
- `GET /api/products/{id}` - Get product by ID
- `POST /api/products` - Create product (admin only)
- `PUT /api/products/{id}` - Update product (admin only)
- `DELETE /api/products/{id}` - Delete product (admin only)
- `GET /api/products/search` - Search products by name/generic

### 6.8 CustomersController

**Endpoints:**
- `GET /api/customers` - Get all customers
- `GET /api/customers/{id}` - Get customer by ID
- `POST /api/customers` - Create customer (admin only)
- `PUT /api/customers/{id}` - Update customer (admin only)
- `DELETE /api/customers/{id}` - Delete customer (admin only)
- `GET /api/customers/{id}/outstanding` - Get customer outstanding details
- `GET /api/customers/{id}/sales-history` - Get sales history

### 6.9 SchemesController

**Endpoints:**
- `GET /api/schemes` - Get all schemes
- `GET /api/schemes/{id}` - Get scheme by ID
- `POST /api/schemes` - Create scheme (admin only)
- `PUT /api/schemes/{id}` - Update scheme (admin only)
- `DELETE /api/schemes/{id}` - Delete scheme (admin only)
- `GET /api/schemes/company/{companyId}` - Get schemes by company
- `GET /api/schemes/active` - Get currently active schemes
- `POST /api/schemes/calculate` - Calculate scheme benefit for given quantity

**Models:**
```csharp
public class CalculateSchemeDto
{
    [Required]
    public int SchemeId { get; set; }
    
    [Required]
    public int Quantity { get; set; }
}

public class SchemeCalculationResultDto
{
    public bool IsApplicable { get; set; }
    public int FreeQuantity { get; set; }
    public decimal DiscountAmount { get; set; }
    public decimal EffectiveRate { get; set; }
    public decimal Savings { get; set; }
}
```

### 6.10 RateMasterController

**Endpoints:**
- `GET /api/ratemaster` - Get all rate configurations
- `GET /api/ratemaster/product/{productId}` - Get rates for product
- `POST /api/ratemaster` - Create/Update rate (admin only)
- `DELETE /api/ratemaster/{id}` - Delete rate config (admin only)
- `POST /api/ratemaster/calculate-price` - Calculate selling price

**Models:**
```csharp
public class CalculatePriceDto
{
    [Required]
    public int ProductId { get; set; }
    
    [Required]
    public string CustomerType { get; set; } // A, B, C
    
    [Required]
    public decimal CostPrice { get; set; }
}

public class PriceCalculationResultDto
{
    public decimal CostPrice { get; set; }
    public decimal MarginPercent { get; set; }
    public decimal CalculatedPrice { get; set; }
    public decimal MinimumPrice { get; set; }
    public decimal FinalSellingPrice { get; set; }
}
```

### 6.11 ReportsController

**Endpoints:**
- `GET /api/reports/sales-summary` - Sales summary report
- `GET /api/reports/purchase-summary` - Purchase summary report
- `GET /api/reports/inventory-valuation` - Stock valuation report
- `GET /api/reports/customer-outstanding` - Outstanding report
- `GET /api/reports/profit-loss` - P&L statement
- `GET /api/reports/scheme-utilization` - Scheme usage report
- `GET /api/reports/expiry-analysis` - Expiry analysis report

**Parameters:**
```csharp
public class ReportParametersDto
{
    public DateTime? FromDate { get; set; }
    public DateTime? ToDate { get; set; }
    public int? CustomerId { get; set; }
    public int? CompanyId { get; set; }
    public int? ProductId { get; set; }
    public string GroupBy { get; set; } // day, week, month
}
```

---

## 7. Validation and Error Handling

### 7.1 FluentValidation Examples

**PharmaSuite.Services/Validators/CreatePurchaseValidator.cs:**
```csharp
public class CreatePurchaseValidator : AbstractValidator<CreatePurchaseDto>
{
    public CreatePurchaseValidator()
    {
        RuleFor(x => x.CompanyId)
            .GreaterThan(0)
            .WithMessage("Valid company must be selected");

        RuleFor(x => x.PurchaseDate)
            .NotEmpty()
            .LessThanOrEqualTo(DateTime.Today.AddDays(1))
            .WithMessage("Purchase date cannot be in future");

        RuleFor(x => x.Items)
            .NotEmpty()
            .WithMessage("At least one item must be added");

        RuleForEach(x => x.Items)
            .SetValidator(new CreatePurchaseItemValidator());

        RuleFor(x => x.PaymentStatus)
            .Must(status => new[] { "Pending", "Paid", "Partial" }.Contains(status))
            .WithMessage("Invalid payment status");

        RuleFor(x => x.PaidAmount)
            .GreaterThanOrEqualTo(0)
            .WithMessage("Paid amount cannot be negative");

        When(x => x.PaymentStatus == "Paid" || x.PaymentStatus == "Partial", () =>
        {
            RuleFor(x => x.TransactionId)
                .NotEmpty()
                .WithMessage("Transaction ID required for paid/partial payments");
        });
    }
}

public class CreatePurchaseItemValidator : AbstractValidator<CreatePurchaseItemDto>
{
    public CreatePurchaseItemValidator()
    {
        RuleFor(x => x.ProductId)
            .GreaterThan(0);

        RuleFor(x => x.BrandName)
            .NotEmpty()
            .MaximumLength(200);

        RuleFor(x => x.Quantity)
            .GreaterThan(0)
            .WithMessage("Quantity must be greater than zero");

        RuleFor(x => x.Rate)
            .GreaterThan(0)
            .WithMessage("Rate must be greater than zero");

        RuleFor(x => x.BatchNumber)
            .NotEmpty()
            .MaximumLength(50);

        RuleFor(x => x.ExpiryDate)
            .GreaterThan(DateTime.Today)
            .WithMessage("Expiry date must be in future");
    }
}
```

### 7.2 Global Error Handler

**PharmaSuite.API/Middleware/ErrorHandlingMiddleware.cs:**
```csharp
public class ErrorHandlingMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger<ErrorHandlingMiddleware> _logger;

    public ErrorHandlingMiddleware(
        RequestDelegate next, 
        ILogger<ErrorHandlingMiddleware> logger)
    {
        _next = next;
        _logger = logger;
    }

    public async Task InvokeAsync(HttpContext context)
    {
        try
        {
            await _next(context);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "An error occurred");
            await HandleExceptionAsync(context, ex);
        }
    }

    private static Task HandleExceptionAsync(HttpContext context, Exception exception)
    {
        context.Response.ContentType = "application/json";

        var response = exception switch
        {
            ValidationException validationEx => new
            {
                StatusCode = StatusCodes.Status400BadRequest,
                Message = "Validation failed",
                Errors = validationEx.Errors.Select(e => e.ErrorMessage)
            },
            DbUpdateConcurrencyException => new
            {
                StatusCode = StatusCodes.Status409Conflict,
                Message = "Record was modified by another user"
            },
            KeyNotFoundException => new
            {
                StatusCode = StatusCodes.Status404NotFound,
                Message = "Resource not found"
            },
            UnauthorizedAccessException => new
            {
                StatusCode = StatusCodes.Status403Forbidden,
                Message = "Access denied"
            },
            _ => new
            {
                StatusCode = StatusCodes.Status500InternalServerError,
                Message = "An error occurred processing your request"
            }
        };

        context.Response.StatusCode = response.StatusCode;
        return context.Response.WriteAsJsonAsync(response);
    }
}
```

### 7.3 Standard Response Format

```csharp
public class ApiResponse<T>
{
    public bool Success { get; set; }
    public T Data { get; set; }
    public string Message { get; set; }
    public List<string> Errors { get; set; }

    public static ApiResponse<T> SuccessResponse(T data, string message = null)
    {
        return new ApiResponse<T>
        {
            Success = true,
            Data = data,
            Message = message
        };
    }

    public static ApiResponse<T> ErrorResponse(string message, List<string> errors = null)
    {
        return new ApiResponse<T>
        {
            Success = false,
            Message = message,
            Errors = errors ?? new List<string>()
        };
    }
}
```

---

## 8. Performance Optimization

### 8.1 Implement Pagination

```csharp
public class PaginatedResult<T>
{
    public List<T> Data { get; set; }
    public int PageNumber { get; set; }
    public int PageSize { get; set; }
    public int TotalRecords { get; set; }
    public int TotalPages { get; set; }
    public bool HasPreviousPage => PageNumber > 1;
    public bool HasNextPage => PageNumber < TotalPages;
}

// Usage in service
public async Task<PaginatedResult<PurchaseDto>> GetAllAsync(
    int page, int pageSize)
{
    var query = _context.Purchases
        .Include(p => p.Company)
        .Include(p => p.PurchaseItems)
        .AsNoTracking();

    var totalRecords = await query.CountAsync();
    
    var data = await query
        .OrderByDescending(p => p.PurchaseDate)
        .Skip((page - 1) * pageSize)
        .Take(pageSize)
        .ToListAsync();

    return new PaginatedResult<PurchaseDto>
    {
        Data = _mapper.Map<List<PurchaseDto>>(data),
        PageNumber = page,
        PageSize = pageSize,
        TotalRecords = totalRecords,
        TotalPages = (int)Math.Ceiling(totalRecords / (double)pageSize)
    };
}
```

### 8.2 Use AsNoTracking for Read Operations

```csharp
// For queries where you don't need change tracking
var products = await _context.Products
    .AsNoTracking()
    .Where(p => p.IsActive)
    .ToListAsync();
```

### 8.3 Implement Caching

```csharp
// Add in Program.cs
builder.Services.AddMemoryCache();

// Usage in service
public class ProductService
{
    private readonly IMemoryCache _cache;
    private readonly ApplicationDbContext _context;

    public async Task<List<ProductDto>> GetActiveProductsAsync()
    {
        const string cacheKey = "active_products";
        
        if (!_cache.TryGetValue(cacheKey, out List<ProductDto> products))
        {
            products = await _context.Products
                .AsNoTracking()
                .Where(p => p.IsActive)
                .ProjectTo<ProductDto>(_mapper.ConfigurationProvider)
                .ToListAsync();

            _cache.Set(cacheKey, products, TimeSpan.FromMinutes(30));
        }

        return products;
    }
}
```

### 8.4 Use Stored Procedures for Complex Queries

```csharp
// For complex reports
var salesSummary = await _context.Database
    .SqlQueryRaw<SalesSummaryDto>(@"
        EXEC GetSalesSummary @FromDate, @ToDate",
        new SqlParameter("@FromDate", fromDate),
        new SqlParameter("@ToDate", toDate))
    .ToListAsync();
```

### 8.5 Optimize Includes

```csharp
// Instead of multiple includes
var purchase = await _context.Purchases
    .Include(p => p.Company)
    .Include(p => p.PurchaseItems)
        .ThenInclude(pi => pi.Product)
    .Include(p => p.PurchaseItems)
        .ThenInclude(pi => pi.Scheme)
    .FirstOrDefaultAsync(p => p.Id == id);

// Use explicit loading when needed
var purchase = await _context.Purchases
    .Include(p => p.Company)
    .FirstOrDefaultAsync(p => p.Id == id);

// Load related data only if needed
if (includeItems)
{
    await _context.Entry(purchase)
        .Collection(p => p.PurchaseItems)
        .LoadAsync();
}
```

---

## 9. Deployment Considerations

### 9.1 Environment Configuration

**appsettings.Production.json:**
```json
{
  "ConnectionStrings": {
    "DefaultConnection": "Server=production-server;Database=PharmaSuiteDB;User Id=pharma_user;Password=SecurePassword123!;TrustServerCertificate=True"
  },
  "Logging": {
    "LogLevel": {
      "Default": "Warning"
    }
  }
}
```

### 9.2 Optimize for Hosting Cost

**Strategies:**
1. **Use Connection Pooling** (enabled by default in EF Core)
2. **Implement Response Compression**:
   ```csharp
   builder.Services.AddResponseCompression(options =>
   {
       options.EnableForHttps = true;
   });
   ```
3. **Use Minimal APIs** for simple endpoints
4. **Implement Rate Limiting**:
   ```csharp
   builder.Services.AddRateLimiter(options =>
   {
       options.GlobalLimiter = PartitionedRateLimiter.Create<HttpContext, string>(context =>
       {
           return RateLimitPartition.GetFixedWindowLimiter(
               partitionKey: context.User.Identity?.Name ?? context.Request.Headers.Host.ToString(),
               factory: partition => new FixedWindowRateLimiterOptions
               {
                   AutoReplenishment = true,
                   PermitLimit = 100,
                   Window = TimeSpan.FromMinutes(1)
               });
       });
   });
   ```
5. **Enable Gzip Compression**
6. **Use Azure App Service Basic tier** for cost-effective hosting

### 9.3 Database Optimization

- Create proper indexes on foreign keys
- Use composite indexes for filter combinations
- Regular index maintenance
- Archive old records to separate tables

### 9.4 Security Best Practices

1. **Always use HTTPS** in production
2. **Implement CORS** properly:
   ```csharp
   builder.Services.AddCors(options =>
   {
       options.AddPolicy("AllowReactApp", builder =>
       {
           builder.WithOrigins("https://yourdomain.com")
                  .AllowAnyMethod()
                  .AllowAnyHeader();
       });
   });
   ```
3. **Add Request Validation**
4. **Implement SQL Injection protection** (EF Core parameterizes queries)
5. **Use Environment Variables** for secrets

---

## 10. Testing Strategy

### 10.1 Unit Tests

```csharp
// Example unit test
public class PurchaseServiceTests
{
    [Fact]
    public async Task CreatePurchase_ValidData_ReturnsCreatedPurchase()
    {
        // Arrange
        var options = new DbContextOptionsBuilder<ApplicationDbContext>()
            .UseInMemoryDatabase(databaseName: "TestDb")
            .Options;

        using var context = new ApplicationDbContext(options);
        var service = new PurchaseService(context, mapper);

        var dto = new CreatePurchaseDto
        {
            CompanyId = 1,
            PurchaseDate = DateTime.Today,
            PaymentStatus = "Pending",
            Items = new List<CreatePurchaseItemDto> { /* items */ }
        };

        // Act
        var result = await service.CreateAsync(dto, 1);

        // Assert
        Assert.NotNull(result);
        Assert.Equal(1, result.CompanyId);
    }
}
```

### 10.2 Integration Tests

Test complete API workflows including database operations.

---

## 11. Summary Checklist

### Development Steps:
- [ ] Create solution and projects
- [ ] Install NuGet packages
- [ ] Create entity models with proper attributes
- [ ] Configure DbContext and relationships
- [ ] Create and run migrations
- [ ] Implement JWT authentication
- [ ] Create repositories and services
- [ ] Implement DTOs and AutoMapper profiles
- [ ] Create controllers with all endpoints
- [ ] Add FluentValidation validators
- [ ] Implement error handling middleware
- [ ] Add pagination and caching
- [ ] Configure CORS
- [ ] Add Swagger documentation
- [ ] Write unit and integration tests
- [ ] Deploy to hosting

### Key Points to Remember:
1. **Always use async/await** for database operations
2. **Use DTOs** instead of entities in API responses
3. **Implement optimistic concurrency** with RowVersion
4. **Add proper indexes** for query performance
5. **Use AsNoTracking** for read-only queries
6. **Implement pagination** for large datasets
7. **Add proper validation** at all levels
8. **Use role-based authorization** consistently
9. **Log errors** with Serilog
10. **Test with realistic data volumes**

---

**Document Version**: 1.0  
**Target Audience**: Junior .NET Developers (1 year experience)  
**Estimated Development Time**: 4-6 weeks  
**Last Updated**: November 2025
